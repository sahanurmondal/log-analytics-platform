# Sliding Window Problems

Sliding window technique problems for subarray/substring optimization and two-pointer variations.

## Problem List (Grouped by Difficulty)

### Medium
| Problem Name | LeetCode Link | Code Link |
|--------------|--------------|-----------|
| Binary Subarrays With Sum | [LeetCode Problem](https://leetcode.com/problems/binary-subarrays-with-sum/) | [BinarySubarraysWithSum.java](./medium/BinarySubarraysWithSum.java) |
| Contains Duplicate II | [LeetCode Problem](https://leetcode.com/problems/contains-duplicate-ii/) | [ContainsDuplicateII.java](./medium/ContainsDuplicateII.java) |
| Contains Duplicate III | [LeetCode Problem](https://leetcode.com/problems/contains-duplicate-iii/) | [ContainsDuplicateIII.java](./medium/ContainsDuplicateIII.java) |
| Count Vowel Substrings | [LeetCode Problem](https://leetcode.com/problems/count-vowel-substrings/) | [CountVowelSubstrings.java](./medium/CountVowelSubstrings.java) |
| Find All Anagrams In String | [LeetCode Problem](https://leetcode.com/problems/find-all-anagrams-in-string/) | [FindAllAnagramsInString.java](./medium/FindAllAnagramsInString.java) |
| Find KLength Substrings With No Repeated Characters | [LeetCode Problem](https://leetcode.com/problems/find-klength-substrings-with-no-repeated-characters/) | [FindKLengthSubstringsWithNoRepeatedCharacters.java](./medium/FindKLengthSubstringsWithNoRepeatedCharacters.java) |
| Fruit Into Baskets | [LeetCode Problem](https://leetcode.com/problems/fruit-into-baskets/) | [FruitIntoBaskets.java](./medium/FruitIntoBaskets.java) |
| Get Equal Substrings Within Budget | [LeetCode Problem](https://leetcode.com/problems/get-equal-substrings-within-budget/) | [GetEqualSubstringsWithinBudget.java](./medium/GetEqualSubstringsWithinBudget.java) |
| Grumpy Bookstore Owner | [LeetCode Problem](https://leetcode.com/problems/grumpy-bookstore-owner/) | [GrumpyBookstoreOwner.java](./medium/GrumpyBookstoreOwner.java) |
| Longest Nice Subarray | [LeetCode Problem](https://leetcode.com/problems/longest-nice-subarray/) | [LongestNiceSubarray.java](./medium/LongestNiceSubarray.java) |
| Longest Repeating Character Replacement | [LeetCode Problem](https://leetcode.com/problems/longest-repeating-character-replacement/) | [LongestRepeatingCharacterReplacement.java](./medium/LongestRepeatingCharacterReplacement.java) |
| Longest Subarray Of1s After Deleting One Element | [LeetCode Problem](https://leetcode.com/problems/longest-subarray-of1s-after-deleting-one-element/) | [LongestSubarrayOf1sAfterDeletingOneElement.java](./medium/LongestSubarrayOf1sAfterDeletingOneElement.java) |
| Longest Subarray With At Most KDistinct Characters | [LeetCode Problem](https://leetcode.com/problems/longest-subarray-with-at-most-kdistinct-characters/) | [LongestSubarrayWithAtMostKDistinctCharacters.java](./medium/LongestSubarrayWithAtMostKDistinctCharacters.java) |
| Max Consecutive Ones III | [LeetCode Problem](https://leetcode.com/problems/max-consecutive-ones-iii/) | [MaxConsecutiveOnesIII.java](./medium/MaxConsecutiveOnesIII.java) |
| Maximum Average Subarray I | [LeetCode Problem](https://leetcode.com/problems/maximum-average-subarray-i/) | [MaximumAverageSubarrayI.java](./medium/MaximumAverageSubarrayI.java) |
| Maximum Sum Of Distinct Subarrays | [LeetCode Problem](https://leetcode.com/problems/maximum-sum-of-distinct-subarrays/) | [MaximumSumOfDistinctSubarrays.java](./medium/MaximumSumOfDistinctSubarrays.java) |
| Maximum Sum Subarray Of Size K | [LeetCode Problem](https://leetcode.com/problems/maximum-sum-subarray-of-size-k/) | [MaximumSumSubarrayOfSizeK.java](./medium/MaximumSumSubarrayOfSizeK.java) |
| Max Points From Cards | [LeetCode Problem](https://leetcode.com/problems/max-points-from-cards/) | [MaxPointsFromCards.java](./medium/MaxPointsFromCards.java) |
| Minimum Size Subarray Sum | [LeetCode Problem](https://leetcode.com/problems/minimum-size-subarray-sum/) | [MinimumSizeSubarraySum.java](./medium/MinimumSizeSubarraySum.java) |
| Permutation In String | [LeetCode Problem](https://leetcode.com/problems/permutation-in-string/) | [PermutationInString.java](./medium/PermutationInString.java) |
| Repeated String Match | [LeetCode Problem](https://leetcode.com/problems/repeated-string-match/) | [RepeatedStringMatch.java](./medium/RepeatedStringMatch.java) |
| Subarray Product Less Than K | [LeetCode Problem](https://leetcode.com/problems/subarray-product-less-than-k/) | [SubarrayProductLessThanK.java](./medium/SubarrayProductLessThanK.java) |

### Hard
| Problem Name | LeetCode Link | Code Link |
|--------------|--------------|-----------|
| Constrained Subsequence Sum | [LeetCode Problem](https://leetcode.com/problems/constrained-subsequence-sum/) | [ConstrainedSubsequenceSum.java](./hard/ConstrainedSubsequenceSum.java) |
| Count Subarrays With Fixed Bounds | [LeetCode Problem](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/) | [CountSubarraysWithFixedBounds.java](./hard/CountSubarraysWithFixedBounds.java) |
| Minimum Number Of Flips To Make Binary String Alternating | [LeetCode Problem](https://leetcode.com/problems/minimum-number-of-flips-to-make-binary-string-alternating/) | [MinimumNumberOfFlipsToMakeBinaryStringAlternating.java](./hard/MinimumNumberOfFlipsToMakeBinaryStringAlternating.java) |
| Minimum Window Covering All Characters | [LeetCode Problem](https://leetcode.com/problems/minimum-window-covering-all-characters/) | [MinimumWindowCoveringAllCharacters.java](./hard/MinimumWindowCoveringAllCharacters.java) |
| Minimum Window Subsequence | [LeetCode Problem](https://leetcode.com/problems/minimum-window-subsequence/) | [MinimumWindowSubsequence.java](./hard/MinimumWindowSubsequence.java) |
| Minimum Window With Character Frequency | [LeetCode Problem](https://leetcode.com/problems/minimum-window-with-character-frequency/) | [MinimumWindowWithCharacterFrequency.java](./hard/MinimumWindowWithCharacterFrequency.java) |
| Number Of Substrings Containing All Three Characters | [LeetCode Problem](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/) | [NumberOfSubstringsContainingAllThreeCharacters.java](./hard/NumberOfSubstringsContainingAllThreeCharacters.java) |
| Shortest Subarray With Sum At Least K | [LeetCode Problem](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/) | [ShortestSubarrayWithSumAtLeastK.java](./hard/ShortestSubarrayWithSumAtLeastK.java) |
| Sliding Window Average | [LeetCode Problem](https://leetcode.com/problems/sliding-window-average/) | [SlidingWindowAverage.java](./hard/SlidingWindowAverage.java) |
| Sliding Window Maximum Deque | [LeetCode Problem](https://leetcode.com/problems/sliding-window-maximum-deque/) | [SlidingWindowMaximumDeque.java](./hard/SlidingWindowMaximumDeque.java) |
| Sliding Window Median | [LeetCode Problem](https://leetcode.com/problems/sliding-window-median/) | [SlidingWindowMedian.java](./hard/SlidingWindowMedian.java) |
| Sliding Window Minimum | [LeetCode Problem](https://leetcode.com/problems/sliding-window-minimum/) | [SlidingWindowMinimum.java](./hard/SlidingWindowMinimum.java) |
| Subarrays With KDifferent Integers | [LeetCode Problem](https://leetcode.com/problems/subarrays-with-kdifferent-integers/) | [SubarraysWithKDifferentIntegers.java](./hard/SubarraysWithKDifferentIntegers.java) |

## Core Algorithms & Techniques

### Key Patterns Used
- Pattern identification and implementation details
- Time and space complexity analysis
- Common approaches and optimizations

### Algorithm Categories
- **Time Complexity**: Various complexity patterns from O(1) to O(n²)
- **Space Complexity**: In-place vs auxiliary space solutions
- **Approach Types**: Iterative, recursive, and hybrid solutions

## Implementation Features

### Each Problem Includes:
- ✅ Multiple solution approaches when applicable
- ✅ Comprehensive test cases with edge cases
- ✅ Time and space complexity analysis
- ✅ Detailed comments and explanations
- ✅ Follow-up questions and variations

### Code Quality Standards:
- Clean, readable implementations
- Proper error handling
- Edge case coverage
- Performance optimizations
- Interview-ready format

## Study Recommendations

### Difficulty Progression:
1. **Easy**: Master fundamental concepts and basic implementations
2. **Medium**: Learn advanced techniques and optimization strategies  
3. **Hard**: Practice complex algorithms and edge case handling

### Key Focus Areas:
- Understanding core algorithms and data structures
- Pattern recognition and template usage
- Time/space complexity optimization
- Edge case identification and handling

## Notes
- Each implementation includes detailed explanations
- Focus on understanding patterns rather than memorizing solutions
- Practice multiple approaches for comprehensive understanding
- Test with various input scenarios for robust solutions
